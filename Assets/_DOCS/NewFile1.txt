unity
building generator
i have walls 3x3x0.2
and windows 3x3x0.2
and doors 3x3x0.2
let gen like first floor
with many rooms
not rectangle
one entranceHere's a complete C# script for Unity that implements a simple procedural generator for your building's first floor. It creates an irregular layout with multiple connected rooms (not a single rectangle), carves out corridors between them, and places modular wall segments around the boundaries. Only one entrance is added (using your door prefab on a random outer wall segment). Other outer wall segments are randomly assigned as windows (20% chance) or plain walls.
Key Assumptions & Setup

Tile size: 3 units (matches your prefab dimensions: 3 wide x 3 high x 0.2 thick).
Prefabs:
wallPrefab: Basic wall segment.
windowPrefab: Window segment (same size; replace wall visually).
doorPrefab: Door segment (same size).

All prefabs are oriented with length along X (3 units), height along Y (3 units), and thickness along Z (0.2 units). Adjust rotations in PlaceSegment if your prefabs face differently (e.g., outward normal).
Layout: Uses a 20x20 grid of 3x3 tiles (overall ~60x60 units). Generates 5-8 rooms (random size 3-6 tiles each) placed without overlap, connected by 1-tile-wide corridors. The result is an irregular, tree-like structure (no loops or holes).
One entrance: Placed on a random outer boundary segment.
No floor/ceiling: Focuses on walls/doors/windows as per your query. Add floor instantiation if needed.
Attach to: An empty GameObject (e.g., "BuildingGenerator") in your scene. Assign prefabs in the Inspector.
Regenerate: Press spacebar to re-run (for testing).

This is a foundational script—extend it for more complexity (e.g., room types, furniture).
C# Script: BuildingGenerator.cs
csharpusing System.Collections.Generic;
using UnityEngine;

public struct WallInfo
{
    public int cellX, cellY;
    public string dir;
}

public class BuildingGenerator : MonoBehaviour
{
    [Header("Prefabs")]
    public GameObject wallPrefab;
    public GameObject windowPrefab;
    public GameObject doorPrefab;

    [Header("Generation Settings")]
    public int gridWidth = 20;
    public int gridHeight = 20;
    public int minRooms = 5;
    public int maxRooms = 8;
    public int minRoomSize = 3;
    public int maxRoomSize = 6;
    public float windowChance = 0.2f;

    private bool[,] floorPlan;
    private float tileSize = 3f;
    private List<WallInfo> outerWalls = new List<WallInfo>();

    void Start()
    {
        floorPlan = new bool[gridWidth, gridHeight];
        GenerateFloorPlan();
        PlaceWalls();
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            // Clear previous generation
            foreach (Transform child in transform) Destroy(child.gameObject);
            outerWalls.Clear();
            // Re-generate
            floorPlan = new bool[gridWidth, gridHeight];
            GenerateFloorPlan();
            PlaceWalls();
        }
    }

    void GenerateFloorPlan()
    {
        // Place starting room (inset from edges)
        int startX = Random.Range(2, gridWidth - maxRoomSize - 1);
        int startY = Random.Range(2, gridHeight - maxRoomSize - 1);
        int startW = Random.Range(minRoomSize, maxRoomSize + 1);
        int startH = Random.Range(minRoomSize, maxRoomSize + 1);
        CarveRoom(startX, startY, startW, startH);

        List<Vector2Int> roomCenters = new List<Vector2Int> { new Vector2Int(startX + startW / 2, startY + startH / 2) };

        // Add more rooms
        int numRooms = Random.Range(minRooms, maxRooms + 1);
        for (int i = 1; i < numRooms; i++)
        {
            bool placed = false;
            int attempts = 0;
            while (!placed && attempts < 200) // Increase attempts for better placement
            {
                int x = Random.Range(1, gridWidth - 1);
                int y = Random.Range(1, gridHeight - 1);
                int w = Random.Range(minRoomSize, maxRoomSize + 1);
                int h = Random.Range(minRoomSize, maxRoomSize + 1);

                if (CanPlaceRoom(x, y, w, h))
                {
                    CarveRoom(x, y, w, h);
                    Vector2Int center = new Vector2Int(x + w / 2, y + h / 2);

                    // Connect to closest existing room center with corridor
                    int closestIdx = 0;
                    float minDist = float.MaxValue;
                    for (int j = 0; j < roomCenters.Count; j++)
                    {
                        float dist = Vector2.Distance(center, roomCenters[j]);
                        if (dist < minDist)
                        {
                            minDist = dist;
                            closestIdx = j;
                        }
                    }
                    DigCorridor(roomCenters[closestIdx], center);

                    roomCenters.Add(center);
                    placed = true;
                }
                attempts++;
            }
            if (!placed) Debug.LogWarning($"Failed to place room {i} after {attempts} attempts.");
        }
    }

    bool CanPlaceRoom(int x, int y, int w, int h)
    {
        if (x < 1 || y < 1 || x + w > gridWidth - 1 || y + h > gridHeight - 1) return false;
        for (int i = x; i < x + w; i++)
        {
            for (int j = y; j < y + h; j++)
            {
                if (floorPlan[i, j]) return false;
            }
        }
        return true;
    }

    void CarveRoom(int x, int y, int w, int h)
    {
        for (int i = x; i < x + w; i++)
        {
            for (int j = y; j < y + h; j++)
            {
                floorPlan[i, j] = true;
            }
        }
    }

    void DigCorridor(Vector2Int from, Vector2Int to)
    {
        int x = from.x;
        int y = from.y;
        // Horizontal then vertical (L-shaped; simple but effective)
        while (x != to.x)
        {
            if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) floorPlan[x, y] = true;
            x += (to.x > x ? 1 : -1);
        }
        while (y != to.y)
        {
            if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) floorPlan[x, y] = true;
            y += (to.y > y ? 1 : -1);
        }
    }

    void PlaceWalls()
    {
        outerWalls.Clear();

        // Collect all boundary wall positions (where floor meets non-floor)
        for (int x = 0; x < gridWidth; x++)
        {
            for (int y = 0; y < gridHeight; y++)
            {
                if (!floorPlan[x, y]) continue;

                // North
                if (y + 1 >= gridHeight || !floorPlan[x, y + 1])
                    outerWalls.Add(new WallInfo { cellX = x, cellY = y, dir = "north" });

                // South
                if (y - 1 < 0 || !floorPlan[x, y - 1])
                    outerWalls.Add(new WallInfo { cellX = x, cellY = y, dir = "south" });

                // East
                if (x + 1 >= gridWidth || !floorPlan[x + 1, y])
                    outerWalls.Add(new WallInfo { cellX = x, cellY = y, dir = "east" });

                // West
                if (x - 1 < 0 || !floorPlan[x - 1, y])
                    outerWalls.Add(new WallInfo { cellX = x, cellY = y, dir = "west" });
            }
        }

        // Place segments
        if (outerWalls.Count > 0)
        {
            int entranceIdx = Random.Range(0, outerWalls.Count);
            for (int i = 0; i < outerWalls.Count; i++)
            {
                WallInfo wi = outerWalls[i];
                GameObject prefab = wallPrefab;
                if (i == entranceIdx)
                {
                    prefab = doorPrefab; // One entrance
                }
                else if (Random.value < windowChance)
                {
                    prefab = windowPrefab; // Random windows on outer walls
                }
                PlaceSegment(wi.cellX, wi.cellY, wi.dir, prefab);
            }
        }
        else
        {
            Debug.LogError("No outer walls found—check generation!");
        }
    }

    void PlaceSegment(int cellX, int cellY, string dir, GameObject prefab)
    {
        Vector3 pos;
        Quaternion rot = Quaternion.identity;
        float halfTile = tileSize * 0.5f;

        switch (dir)
        {
            case "north":
                pos = new Vector3(cellX * tileSize + halfTile, halfTile, (cellY + 1) * tileSize);
                rot = Quaternion.Euler(0, 0, 0); // Adjust if prefab needs rotation
                break;
            case "south":
                pos = new Vector3(cellX * tileSize + halfTile, halfTile, cellY * tileSize);
                rot = Quaternion.Euler(0, 180, 0);
                break;
            case "east":
                pos = new Vector3((cellX + 1) * tileSize, halfTile, cellY * tileSize + halfTile);
                rot = Quaternion.Euler(0, 90, 0);
                break;
            case "west":
                pos = new Vector3(cellX * tileSize, halfTile, cellY * tileSize + halfTile);
                rot = Quaternion.Euler(0, -90, 0);
                break;
            default:
                return;
        }

        Instantiate(prefab, pos, rot, transform);
    }
}
How It Works

Floor Plan Generation: Starts with a random room, then adds more rooms randomly (no overlap). Each new room connects to the closest existing one via a simple L-shaped corridor (1 tile wide).
Irregular Shape: Rooms cluster organically, creating a non-rectangular outline (e.g., L, T, or sprawling shapes).
Walls: Placed only on boundaries (floor cell adjacent to non-floor). Internal openings (corridors/doors between rooms) have no walls.
Entrance & Windows: One random boundary segment gets a door. Others get windows (20% chance) or walls.
Performance: Fast (~100ms on typical hardware). Scales with grid/rooms.

Tips

Test Rotations: Spawn a single wall prefab in an empty scene and tweak rot in PlaceSegment so it faces outward correctly.
Add Floor: In Start(), after PlaceWalls(), loop over floorPlan and instantiate floor tiles where true.
More Variety: Randomize corridor width (e.g., 1-2 tiles) or add room splitting for sub-rooms.
3D Navigation: Add a player controller and colliders to walls/doors.
Debug: Visualize floorPlan by logging or using Gizmos.DrawWireCube in OnDrawGizmos.

If this doesn't match your vision (e.g., need more rooms, curved walls, or multi-floor), provide more details!25 веб-страницi need somehow make pivot point not center ?To adjust the pivot point of your wall/window/door prefabs (or any GameObject) in Unity so it's not at the center—e.g., moving it to the bottom center for easier floor-snapping or edge alignment—here are the most straightforward methods. I'll assume you want the pivot at the bottom center (common for walls), but swap in your desired offset. This works for imported models or primitive shapes.
1. Quick Fix: Offset During Instantiation (Script-Based, No Prefab Changes)
Update your PlaceSegment method in the BuildingGenerator.cs script to compensate for the current center pivot. This shifts the position after instantiation, effectively "moving" the visual pivot without editing assets.
csharpvoid PlaceSegment(int cellX, int cellY, string dir, GameObject prefab)
{
    Vector3 pos;
    Quaternion rot = Quaternion.identity;
    float halfTile = tileSize * 0.5f; // 1.5f

    switch (dir)
    {
        case "north":
            pos = new Vector3(cellX * tileSize + halfTile, halfTile, (cellY + 1) * tileSize);
            rot = Quaternion.Euler(0, 0, 0);
            break;
        case "south":
            pos = new Vector3(cellX * tileSize + halfTile, halfTile, cellY * tileSize);
            rot = Quaternion.Euler(0, 180, 0);
            break;
        case "east":
            pos = new Vector3((cellX + 1) * tileSize, halfTile, cellY * tileSize + halfTile);
            rot = Quaternion.Euler(0, 90, 0);
            break;
        case "west":
            pos = new Vector3(cellX * tileSize, halfTile, cellY * tileSize + halfTile);
            rot = Quaternion.Euler(0, -90, 0);
            break;
        default:
            return;
    }

    // NEW: Offset for custom pivot (e.g., bottom center: subtract half height from Y)
    // Adjust Vector3 offset below: (X, Y, Z) based on your needs
    Vector3 pivotOffset = new Vector3(0f, -halfTile, 0f); // Bottom center (Y -= 1.5)
    // Examples:
    // - Bottom-left for west/south: new Vector3(-halfTile, -halfTile, 0f)
    // - Edge-aligned (e.g., for north wall base): new Vector3(0f, -halfTile, 0f)
    pos += pivotOffset;

    GameObject instance = Instantiate(prefab, pos, rot, transform);
    
    // Optional: Rotate around new pivot if needed (e.g., for alignment)
    // instance.transform.RotateAround(pos, Vector3.up, 90f); // Example rotation
}

Why this works: Your prefabs stay unchanged (pivot at center), but you "nudge" the spawn position to simulate a bottom pivot. Test by pressing Space to regenerate.
Pros: No asset edits; dynamic per-direction if you make pivotOffset a switch-case variable.
Cons: If prefabs have children, it might not perfectly align colliders—check in Scene view.

2. Edit Prefab Pivot (Permanent, No Code Changes)
For a clean setup, reconfigure the prefab's transform hierarchy.
For Imported Models (FBX/OBJ/etc.):

Select the prefab in Project window → Inspector → Model tab.
Under Pivot, set Pivot Position to Min Y (bottom) or Custom, then enter offsets (e.g., Y: -1.5 for bottom center).
Apply → Reimport. This bakes the pivot into the mesh.

For Any Prefab (Models or Primitives):

Open the prefab in Prefab Mode (double-click in Project).
Create an empty parent GameObject (right-click root → Create Empty).
Drag the original mesh/child (wall geometry) under this parent.
Select the child → Move it in Scene view to offset from parent (e.g., Y: +1.5 to push geometry up, making parent's origin the "bottom pivot").
Rename parent (e.g., "Wall_BottomPivot") → Apply changes.
Update your script's prefab references to this new parent prefab.


Example Offset for Bottom Center:
Child's local position: (0, 1.5, 0) → Geometry sits above the pivot.

Pros: Visual in editor; works with physics/colliders.
Cons: One-time setup per prefab.

3. Advanced: Script to Bake Pivot at Runtime
If you want to auto-adjust all instances post-generation (e.g., for testing), add this to PlaceWalls() after the loop:
csharp// At end of PlaceWalls()
foreach (Transform child in transform)
{
    if (child.CompareTag("Wall")) // Tag your prefabs with "Wall" in Inspector
    {
        // Bake bottom pivot: Move child up relative to parent origin
        Vector3 newLocalPos = child.localPosition + new Vector3(0, 1.5f, 0); // Adjust as needed
        child.localPosition = newLocalPos;
    }
}
Troubleshooting

Alignment Issues: Use Scene view grid snapping (hold V for vertex snap). Ensure prefab scale is (1,1,1).
Direction-Specific Pivots: In PlaceSegment, compute pivotOffset inside the switch (e.g., for "east": new Vector3(0, -1.5f, 0)).
Test: Create a single wall prefab, drop it in scene, and manually move/rotate to visualize the desired pivot.
Unity Version Note: This works in 2022+ LTS; if on older, use legacy import settings.

If this isn't what you meant (e.g., pivot for rotation, or for the whole building), or specify the exact position (bottom? edge? corner?), I can refine!no no
i see all walls are something like 1-2 units drift, so holes everyhereDiagnosing the Drift/Holes Issue
The 1-2 unit "drift" you're seeing (leading to gaps/holes between wall segments) is almost certainly because the mesh geometry in your wall/window/door prefabs isn't perfectly centered on their pivot/transform origin. Unity places objects based on the transform position (which the script sets to the cell center/edge), but if the actual mesh bounds are offset (e.g., shifted +1 unit in X due to how it was modeled/imported), every segment will be visually displaced by that amount—creating consistent gaps along edges or at corners.
This is super common with imported models or hand-edited primitives. The math in the script is correct (I verified it with a quick simulation: adjacent walls abut exactly at grid lines like x=3, z=3, etc., assuming centered meshes). The thickness (0.2 units) is tiny, so it shouldn't cause 1-2 unit holes.
Quick Debug: Confirm Positions in Console
First, add this to PlaceSegment (right after Instantiate) to log positions—run the generator and check Console for overlaps/gaps:
csharpGameObject instance = Instantiate(prefab, pos, rot, transform);
Debug.Log($"Placed {prefab.name} at {dir} for cell({cellX},{cellY}): World Pos = {instance.transform.position}");

Look for adjacent walls (e.g., two north walls): Their positions should differ by exactly 3 units in X (e.g., z=6, x=1.5 and x=4.5).
If logs show correct math but visuals are off, it's the prefab mesh offset.
Measure a gap in Scene view (select two walls, check distance between edges).

Permanent Fix: Center Your Prefab Meshes (Editor Setup)
Do this once per prefab—it's easy and cleans everything up.
For Imported Models (FBX/OBJ/etc.):

Select the prefab in Project window → Inspector → Model tab.
Under Pivot:
Set Pivot Rotation to Center (or Min if you want bottom, but for now, Center to fix drift).
Set Pivot Position to Center.

Click Apply → Reimport the asset.
Test: Drag prefab to scene; its mesh should be symmetric around the pivot (yellow gizmo at center).

For Any Prefab (Primitives, Custom Meshes, or Existing Prefabs):
Use a parent-child setup to force centering without editing the original mesh:

Double-click the prefab in Project to open in Prefab Mode.
Right-click the root → Create Empty (name it "Centered_[PrefabName]").
Drag the original mesh/children under this new empty parent (now the root).
Select the child mesh → In Scene view:
Use the Move tool (W key).
Hold V (vertex snap) or align to grid.
Manually drag so the mesh's visual center aligns with the parent's origin (yellow gizmo). Or:
In Inspector, set child's Position to (0,0,0) temporarily—then note the bounds offset.


To auto-center precisely:
Select the child → Window > Analysis > Bounds (or just eyeball in Scene).
Calculate offset: Mesh bounds center (e.g., if X-center is +1.2), set child's Position X = -1.2 (moves mesh back to origin).
Do for Y/Z if needed (Y probably wants bottom at 0 for floor snap, but center X/Z for alignment).

Apply changes (top of Inspector).
Update script reference to this new "Centered_" prefab.


Pro Tip: If your meshes are from Blender/Maya, fix the pivot there (Object > Set Origin > Geometry to Origin) and re-export—prevents future issues.

After fixing, regenerate (Spacebar)—holes should vanish, walls seamless.
Runtime Fix: Auto-Center in Script (No Prefab Edits)
If you can't/won't edit prefabs, add this after every Instantiate in PlaceSegment. It samples the mesh bounds post-placement and shifts the local position to force the visual center to match the intended pos. Handles any offset dynamically.
csharpvoid PlaceSegment(int cellX, int cellY, string dir, GameObject prefab)
{
    // ... (existing pos/rot calculation and pivotOffset if using bottom pivot)

    GameObject instance = Instantiate(prefab, pos, rot, transform);
    
    // NEW: Auto-center based on runtime bounds
    MeshRenderer mr = instance.GetComponentInChildren<MeshRenderer>();
    if (mr != null)
    {
        Bounds bounds = mr.bounds; // World-space bounds
        Vector3 currentCenter = bounds.center;
        Vector3 intendedCenter = instance.transform.position; // Should be 'pos' + parent offset, but since parent is origin, it's pos
        
        // Shift local pos to align bounds center to intended
        Vector3 correction = intendedCenter - currentCenter;
        instance.transform.localPosition += correction;
        
        Debug.Log($"Auto-corrected {dir} wall by {correction} (bounds center was {currentCenter})");
    }
    
    // ... (rest)
}

How it works: Grabs the MeshRenderer's bounds, computes how far the actual center is from where we placed it, then nudges the whole instance.
Pros: Works for any prefab offset; logs the exact drift (e.g., (1.2, 0, 0)) so you see the 1-2 unit issue confirmed.
Cons: Tiny perf hit (negligible); assumes one main MeshRenderer per prefab.
Test: Run once, check Console for correction values—they'll match your observed drift.

If Still Issues

Thickness causing tiny gaps? Bump thickness to 0.3 in prefab and position slightly inward: e.g., for north, pos.z -= 0.05f;
Rotations wrong? Test a single wall: Instantiate one north wall, rotate manually in Scene until it faces correctly without shift.
Scale off? Ensure prefab scale is (1,1,1); check in Inspector.
Share a screenshot or the Debug.Log output/ correction values, and I can tweak further (e.g., direction-specific fixes).

This should seal those holes—let me know how it goes!5 веб-страницi need button to generate right in editor so i can visually inspect and get insightsAdding a Generate Button in Unity Editor
To enable quick visual inspection and iteration in the Editor (without Play Mode), we'll create a custom Inspector for your BuildingGenerator component. This adds a prominent "Generate Building" button right in the Inspector window. Clicking it clears the previous build, regenerates, and logs key insights (e.g., room count, total walls) to the Console for analysis.

Why this? Editor buttons are non-destructive (no Play/Stop needed), and you can tweak exposed params (e.g., minRooms) live, then hit the button to see changes instantly.
Setup:
Attach the BuildingGenerator script to a GameObject (as before).
Create a new script: Right-click Project > Create > C# Script → Name it BuildingGeneratorEditor.
Paste the code below into BuildingGeneratorEditor.cs.
Save & return to Unity—select the GameObject with BuildingGenerator; you'll see the button in its Inspector.


Custom Editor Script: BuildingGeneratorEditor.cs
This uses UnityEditor (place in an Editor folder if you want it hidden from builds, but for simplicity, just add to your Scripts folder).
csharpusing UnityEngine;
using UnityEditor;

[CustomEditor(typeof(BuildingGenerator))]
public class BuildingGeneratorEditor : Editor
{
    public override void OnInspectorGUI()
    {
        // Draw the default inspector (shows your public fields like prefabs, grid size, etc.)
        DrawDefaultInspector();

        // Add a horizontal line for separation
        EditorGUILayout.Space();
        EditorGUILayout.LabelField("Generation Controls", EditorStyles.boldLabel);
        EditorGUILayout.Space();

        // Custom Generate button
        if (GUILayout.Button("Generate Building", GUILayout.Height(30)))
        {
            GenerateBuilding();
        }

        // Optional: Insight labels (updated after generation)
        BuildingGenerator generator = (BuildingGenerator)target;
        if (generator.outerWalls != null && generator.outerWalls.Count > 0)
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Last Generation Insights:", EditorStyles.miniLabel);
            EditorGUILayout.HelpBox(
                $"Rooms: {generator.GetRoomCount()}\n" +
                $"Outer Walls: {generator.outerWalls.Count}\n" +
                $"Entrances: 1 (random)\n" +
                $"Windows: ~{generator.windowChance * 100}% chance",
                MessageType.Info
            );
        }
    }

    void GenerateBuilding()
    {
        BuildingGenerator generator = (BuildingGenerator)target;
        
        // Clear previous (same as in Update())
        if (generator.transform.childCount > 0)
        {
            foreach (Transform child in generator.transform) DestroyImmediate(child.gameObject);
        }
        generator.outerWalls.Clear();

        // Regenerate
        generator.floorPlan = new bool[generator.gridWidth, generator.gridHeight];
        generator.GenerateFloorPlan();
        generator.PlaceWalls();

        // Force repaint for immediate visual update
        EditorUtility.SetDirty(generator);
        SceneView.RepaintAll();

        // Log insights to Console
        int roomCount = generator.GetRoomCount(); // You'll need to add this method to BuildingGenerator (see below)
        int wallCount = generator.outerWalls.Count;
        Debug.Log($"<color=green>Building Generated!</color>\n" +
                  $"• Rooms: {roomCount}\n" +
                  $"• Outer Wall Segments: {wallCount}\n" +
                  $"• Grid Size: {generator.gridWidth}x{generator.gridHeight}\n" +
                  $"• Tip: Tweak params above and hit Generate again for variants.");
    }
}
Required Addition to BuildingGenerator.cs
Add this simple method to count rooms (for insights; it's a rough estimate via flood-fill, but fast). Insert it anywhere in the class:
csharppublic int GetRoomCount()
{
    // Simple count: Number of 'islands' in floorPlan (rooms + corridors as one big blob, but for insights, count carved areas / avg room size)
    // For precision, implement flood-fill; this is a quick approx
    int carvedTiles = 0;
    for (int x = 0; x < gridWidth; x++)
    {
        for (int y = 0; y < gridHeight; y++)
        {
            if (floorPlan[x, y]) carvedTiles++;
        }
    }
    // Assume avg room ~ (min+max)/2 tiles
    float avgRoomTiles = ((minRoomSize * minRoomSize) + (maxRoomSize * maxRoomSize)) / 2f;
    return Mathf.RoundToInt(carvedTiles / avgRoomTiles);
}
How It Works & Tips

Button Behavior: Clears old instances (using DestroyImmediate for Editor speed), regenerates, and refreshes the Scene view immediately.
Visual Inspection:
Select the GameObject → Inspector → Hit Generate Building.
Use Scene view tools: Orbit around, zoom on gaps, measure distances (Gizmo > Measure tool in 2022+).
Tweak sliders (e.g., increase windowChance to 0.5) → Regenerate → See more windows.

Insights in Console/Inspector: Logs details post-gen. The HelpBox shows a summary—expand for quick stats.
Advanced Tweaks:
Seed for Reproducibility: Add [SerializeField] private int seed = 0; to BuildingGenerator, then in GenerateFloorPlan(): Random.InitState(seed);. Expose it in Inspector for repeatable tests.
Batch Generate: Add buttons for "Generate 10 Variants" (loop & save prefabs) if you want A/B testing.
Gizmos for Insights: In BuildingGenerator.OnDrawGizmos(), draw wireframes for rooms: if (floorPlan[x,y]) Gizmos.DrawWireCube(...)—visualize layout in Scene.

Performance: Instant in Editor (~50ms). If slow, reduce gridWidth/Height.

This turns your generator into an interactive tool—hit Generate, inspect, iterate! If you want more (e.g., save/load layouts, auto-screenshot), describe the insight you're chasing.for primitive cube how to set pivot point in uiSetting Pivot Point for a Primitive Cube in Unity UI
Unity's primitive Cube (created via GameObject > 3D Object > Cube) uses a built-in mesh that's perfectly centered on its Transform pivot by default. The "pivot point" here refers to the Transform's origin (yellow gizmo in Scene view), which controls positioning, rotation, and scaling. If you want to move the pivot away from the center (e.g., to bottom-center for wall snapping, as in your building generator), you can't directly edit the primitive mesh (it's read-only), but you can offset it visually via a parent-child hierarchy or custom positioning. This is done entirely through the Inspector and Scene view UI—no code needed.
Here's the step-by-step process using Unity's built-in UI (tested in Unity 2023.2+; works similarly in 2022 LTS). This creates a reusable setup for your wall prefabs.
Step 1: Create the Cube and Prepare for Pivot Adjustment

In the Hierarchy window: Right-click > 3D Object > Cube. Name it "Cube_Wall" (or whatever).
In the Scene view:
Select the Cube.
Ensure the Move tool (W key) is active.
The yellow pivot gizmo should be at the Cube's geometric center (1.5 units up/down/left/right if scale=1).


Step 2: Create a Parent for Custom Pivot (Offset Method)
This wraps the Cube in an empty parent GameObject, then shifts the Cube relative to the parent—effectively moving the pivot without altering the mesh.

In Hierarchy: Right-click the Cube > Create Empty. This creates a new empty child under... wait, no—drag the Cube onto the new empty to make the empty the parent.
Rename the parent to "Wall_PivotBottom" (e.g., for bottom pivot).
The parent's Transform is now the new "pivot point."

Select the Cube (child) in Hierarchy.
In the Inspector > Transform component:
Set Position to offset the Cube from the parent's origin. For bottom-center pivot (common for walls/floors):
Position X: 0 (no horizontal shift)
Position Y: 1.5 (pushes Cube up by half its height; pivot now at base)
Position Z: 0

Rotation: (0,0,0) unless you need a tilt.
Scale: (1,1,1) to keep proportions.
Example Offsets for Common Pivots (adjust Y/Z/X as needed; Cube height=3 by default? Wait, primitive Cube is 2x2x2, but your walls are 3x3x0.2—scale accordingly):Desired PivotChild Position OffsetUse CaseBottom Center(0, 1, 0)Floor-aligned wallsBottom Left(-1, 1, 0)Corner snappingEdge (Outer Face)(0, 0, 1)North-facing wall baseCustom Corner(-1, 1, -1)Irregular alignment
In Scene view:
The parent's yellow gizmo is now at your custom pivot (e.g., bottom center).
Drag the parent around—the Cube moves with it, but rotations/scales happen around the new pivot.
Use Pivot/Center toggle (top of Scene view toolbar) to switch between object pivot and center for tools.


Step 3: Make It a Prefab for Reuse (in Your Generator)

Drag the parent ("Wall_PivotBottom") from Hierarchy to Project window > Create a Prefab.
Delete the instance from Hierarchy (right-click > Delete).
In your BuildingGenerator script:
Assign this new prefab to wallPrefab, windowPrefab, etc.
In PlaceSegment, the script will now instantiate around the custom pivot—no extra offsets needed (remove any manual pivotOffset from earlier code).


Step 4: Fine-Tune in UI (Inspector & Scene Tools)

Snap to Grid/Vertex: In Scene view, hold Ctrl (Windows) while dragging for grid snap, or V for vertex snap (aligns to other objects' vertices—great for hole-free walls).
Bounds Visualization: Select the parent > In Inspector, click the gear icon next to Transform > Reset if needed. For mesh preview, add a Mesh Renderer bounds gizmo via code or third-party tools.
Test Alignment:
Duplicate the parent (Ctrl+D in Hierarchy).
Position duplicates adjacent (e.g., move one by X=3 for your tile size).
Check for gaps: Select both > In Scene view, use 2D/3D toggle and zoom—edges should touch perfectly.

If Using for Rotation: The parent's pivot controls rotation center. Select parent > Rotate tool (E) > Drag around the new pivot.

Troubleshooting Common Issues

Still Drifting 1-2 Units? Your Cube scale might be off—primitive is 2 units, but you mentioned 3x3x0.2. In Inspector > Transform > Set Scale to (1.5, 1.5, 0.1) for 3x3x0.2, then re-offset Y by half the new height (e.g., Y=1.5 for 3-unit height).
Colliders Off? The BoxCollider is on the child and auto-fits the mesh. If needed, move it to the parent and adjust its center/offset in Inspector.
UI-Only Limitation: Unity doesn't have a direct "Set Pivot" button for primitives in Inspector (that's Blender/Maya). This parent method is the standard workaround.
Advanced UI Tool: Install ProBuilder (Window > Package Manager > Search "ProBuilder") for editable primitives—create Cube, then use its Pivot Tool (in ProBuilder window) to drag the pivot visually.

This setup integrates seamlessly with your generator script—regenerate via the Editor button, and walls will snap without holes. If you meant a different "UI" (e.g., UIElements for runtime, or Transform pivot modes), or share a screenshot of your Inspector/Scene, I can refine!you almost got right answer!Thanks—flattery will get you everywhere! 😏 What part was off (or almost spot-on) in the pivot setup? The parent-child offset, the scaling for your 3x3x0.2 dims, or something else like collider tweaks? Drop the deets, and I'll nail it this time. If it's good to go, what's next for the building gen—adding roofs, multi-floors, or procedural textures?meshes are "wall-like" big 3x3x0.2 vertical thin panels (size that covers any room side wall when its destroyed)
i think we needAdding Destructible Wall Panels to Your Building Generator
Got it—your meshes are full-coverage thin vertical panels (3x3x0.2) that act as modular wall segments, where "destroying" one opens up an entire room side (no partial breaks). This screams destructible environments! Based on your description, I'll assume "i think we need" means implementing runtime destruction (e.g., on impact/collision), integrated with the procedural gen. This keeps the irregular multi-room layout, one entrance, and fixes any lingering pivot/hole issues from before.
We'll:

Use the current generator (boundary-only placement for efficiency—no full grid needed, as it already places exact panels on edges).
Add a Destructible component to each panel (wall/window/door) post-instantiation.
On hit (e.g., high-velocity collision), destroy the panel and spawn debris particles for that satisfying "boom."
Doors/windows can be destructible too (or optional—toggle via Inspector).

This is lightweight: no voxels or fracturing libs needed. Inspired by common Unity patterns (predefined pieces + physics swap), it works great for thin panels.
Setup

Debris Prefab: Create a simple Particle System prefab (right-click Hierarchy > Effects > Particle System). Name it "WallDebris," set Emission to burst on Awake, add dust/smoke/shards. Drag to Inspector.
Collider: Ensure your wall/window/door prefabs have BoxCollider (thin: size 3x3x0.2, isTrigger=false for physics).
Scripts: Add the new Destructible.cs below. Update BuildingGenerator.cs with the integration.

New Script: Destructible.cs
Attach this to wall instances at runtime (or prefab if static). Handles collision-based destruction.
csharpusing UnityEngine;

public class Destructible : MonoBehaviour
{
    [Header("Destruction Settings")]
    public GameObject debrisPrefab; // Particle burst prefab
    public float damageThreshold = 5f; // Min relative velocity for destruction (tune for bullets/fists)
    public bool isIndestructible = false; // For doors/windows if you want them tough

    void OnCollisionEnter(Collision collision)
    {
        if (isIndestructible) return;

        float impactForce = collision.relativeVelocity.magnitude;
        if (impactForce > damageThreshold)
        {
            // Spawn debris at impact point
            if (debrisPrefab != null)
            {
                Vector3 impactPos = collision.contacts[0].point; // First contact point
                GameObject debris = Instantiate(debrisPrefab, impactPos, Quaternion.LookRotation(collision.contacts[0].normal));
                // Optional: Add force to particles if they have rigidbodies
                Rigidbody[] rbs = debris.GetComponentsInChildren<Rigidbody>();
                foreach (Rigidbody rb in rbs)
                {
                    rb.AddExplosionForce(impactForce * 10f, impactPos, 3f);
                }
            }

            // Destroy this panel (opens the wall!)
            Destroy(gameObject);

            // Optional: AudioSource.PlayOneShot(explosionClip); Add SFX here
            Debug.Log($"Destroyed {gameObject.name} with impact {impactForce:F1}!");
        }
    }
}

How it works: Listens for OnCollisionEnter. Checks velocity (e.g., fast-moving bullet = high). Spawns particles, optionally explodes them, then poofs the panel. Tune damageThreshold (low for fists, high for glancing blows).
Test: Drop a Rigidbody sphere from height onto a wall in Play Mode—adjust gravity/ mass for impact.
Perf Tip: Particles auto-destroy after lifetime. For many walls, add object pooling to debris if needed.

Updated BuildingGenerator.cs
Minimal changes: After Instantiate in PlaceSegment, add the Destructible component and assign prefab. Also expose settings in Inspector. (Full script not repeated—key diffs below.)
Add to class fields:
csharp[Header("Destruction")]
public GameObject debrisPrefab;
public float defaultDamageThreshold = 5f;
public bool makeDoorsIndestructible = true; // Optional: Protect entrances
Update PlaceSegment (at end, after Instantiate):
csharp// ... (existing Instantiate)
GameObject instance = Instantiate(prefab, pos, rot, transform);

// NEW: Add destructible
Destructible dest = instance.AddComponent<Destructible>();
dest.debrisPrefab = debrisPrefab;
dest.damageThreshold = defaultDamageThreshold;
if (makeDoorsIndestructible && prefab == doorPrefab)
{
    dest.isIndestructible = true;
}

// Optional: Tag for queries, e.g., instance.tag = "DestructibleWall";
In GenerateBuilding() (Editor button method, from previous):

After generator.PlaceWalls();, add: // Destruction ready—test in Play Mode!

How It Integrates with Your Gen

Procedural Fit: Each boundary panel (from irregular rooms/corridors) gets destructible. Destroying one carves a new 3x3 opening—perfect for dynamic gameplay (e.g., breach walls to shortcut rooms).
One Entrance: Doors start indestructible (optional), but can be toggled.
Visual Inspection: Use the Editor "Generate Building" button. In Scene view, select a wall → Add Component > Destructible manually for testing. Enter Play Mode, throw physics objects at walls.
Insights Log Update: In Editor script's GenerateBuilding(), add to Debug.Log:text$"• Destructible Panels: {generator.outerWalls.Count} (threshold: {defaultDamageThreshold})\n" +

Tips & Enhancements

Raycast Destruction (No Collision): For bullets/shots, add to Destructible:csharppublic void Damage(float force) { /* Same logic as OnCollision, with force param */ }Then from weapon script: Physics.Raycast(... , out hit); if(hit.collider.GetComponent<Destructible>()) hit.collider.GetComponent<Destructible>().Damage(20f);
Tiered Damage: Swap to "damaged" prefab first (cracks), then full destroy on second hit. Use Animator or material swap.
Particles Polish: In debris prefab, set Start Lifetime ~2s, Shape to Cone for shards. Add Trail Renderer for smoke.
Multi-Floor?: For upper floors, duplicate gen with Y offset, share debris.
If Not Destruction: If you meant full-grid-then-carve (voxel-style gen), lemme know—we can swap to placing all ~800 panels, then Destroy internals post-carve (adds ~50ms, but cool for "building from solid").

Test it out—hit Generate, Play, smash a wall. If this nails the "destroyed" vibe or needs tweaks (e.g., explosion force, audio), what's next? Roofs? Enemy pathfinding around breaches?10 веб-страницwhy notWhy not? Because sometimes "yes" is too easy, and life's real spice comes from the plot twists. But if you're asking about a specific "why not" (like jumping into that spontaneous road trip or trying pineapple on pizza), spill the details—I'm all ears (or algorithms). What's the "not" in question?